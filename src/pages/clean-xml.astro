---
// Clean XML Tool - Client-side HTML to XML converter for InDesign
---

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clean XML Tool</title>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        margin: 0 auto;
        background: #f5f5f5;
        padding: 2rem;
        max-width: 1200px;
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      }

      .container {
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
        background: white;
        padding: 2rem;
      }

      h1 {
        margin: 0 0 1.5rem 0;
        color: #333;
      }

      .upload-area {
        transition: all 0.3s;
        cursor: pointer;
        margin-bottom: 1.5rem;
        border: 2px dashed #ccc;
        border-radius: 8px;
        padding: 2rem;
        text-align: center;
      }

      .upload-area:hover {
        border-color: #666;
        background: #fafafa;
      }

      .upload-area.dragover {
        border-color: #0066cc;
        background: #e6f2ff;
      }

      input[type="file"] {
        display: none;
      }

      .btn {
        transition: background 0.3s;
        cursor: pointer;
        border: none;
        border-radius: 4px;
        background: #0066cc;
        padding: 0.75rem 1.5rem;
        color: white;
        font-size: 1rem;
      }

      .btn:hover {
        background: #0052a3;
      }

      .btn:disabled {
        cursor: not-allowed;
        background: #ccc;
      }

      .status {
        display: none;
        margin: 1rem 0;
        border-radius: 4px;
        padding: 1rem;
      }

      .status.success {
        display: block;
        border: 1px solid #c3e6cb;
        background: #d4edda;
        color: #155724;
      }

      .status.error {
        display: block;
        border: 1px solid #f5c6cb;
        background: #f8d7da;
        color: #721c24;
      }

      .status.info {
        display: block;
        border: 1px solid #bee5eb;
        background: #d1ecf1;
        color: #0c5460;
      }

      .preview {
        display: none;
        margin-top: 2rem;
      }

      .preview.show {
        display: block;
      }

      .preview h2 {
        margin: 0 0 1rem 0;
        color: #333;
        font-size: 1.25rem;
      }

      .preview-content {
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #f8f8f8;
        padding: 1rem;
        max-height: 400px;
        overflow-y: auto;
        font-size: 0.875rem;
        font-family: "Monaco", "Menlo", monospace;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .actions {
        margin-top: 1rem;
      }

      .filters {
        display: none;
        margin-top: 2rem;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #f8f8f8;
        padding: 1.5rem;
      }

      .filters.show {
        display: block;
      }

      .filters h3 {
        margin: 0 0 1rem 0;
        color: #333;
        font-size: 1rem;
      }

      .filter-group {
        margin-bottom: 1.5rem;
      }

      .filter-group:last-child {
        margin-bottom: 0;
      }

      .filter-group h4 {
        margin: 0 0 0.75rem 0;
        color: #666;
        font-weight: 600;
        font-size: 0.875rem;
      }

      .checkbox-list {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .checkbox-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .checkbox-item input[type="checkbox"] {
        cursor: pointer;
      }

      .checkbox-item label {
        cursor: pointer;
        color: #333;
        font-size: 0.875rem;
        font-family: "Monaco", "Menlo", monospace;
      }

      .filter-actions {
        display: flex;
        gap: 0.5rem;
        margin-top: 1rem;
      }

      .btn-small {
        transition: background 0.3s;
        cursor: pointer;
        border: none;
        border-radius: 4px;
        background: #666;
        padding: 0.5rem 1rem;
        color: white;
        font-size: 0.875rem;
      }

      .btn-small:hover {
        background: #444;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Clean XML Tool for InDesign</h1>
      <p>
        Upload an HTML file to clean and convert it to XML format for InDesign
        import.
      </p>

      <div class="upload-area" id="uploadArea">
        <p>üìÅ Click or drag an HTML file here to upload</p>
        <input type="file" id="fileInput" accept=".html,.htm" />
      </div>

      <div id="status" class="status"></div>

      <div class="filters" id="filters">
        <h3>Attribute Filters</h3>
        <div class="filter-group" id="idFiltersGroup" style="display: none;">
          <h4>IDs</h4>
          <div class="checkbox-list" id="idFilters"></div>
        </div>
        <div class="filter-group" id="classFiltersGroup" style="display: none;">
          <h4>Classes</h4>
          <div class="checkbox-list" id="classFilters"></div>
        </div>
        <div class="filter-actions">
          <button class="btn-small" id="selectAllBtn">Select All</button>
          <button class="btn-small" id="deselectAllBtn">Deselect All</button>
        </div>
      </div>

      <div class="preview" id="preview">
        <h2>Cleaned XML Output:</h2>
        <div class="preview-content" id="previewContent"></div>
        <div class="actions">
          <button class="btn" id="downloadBtn">Download XML</button>
        </div>
      </div>
    </div>

    <script>
      const uploadArea = document.getElementById("uploadArea");
      const fileInput = document.getElementById("fileInput");
      const status = document.getElementById("status");
      const preview = document.getElementById("preview");
      const previewContent = document.getElementById("previewContent");
      const downloadBtn = document.getElementById("downloadBtn");
      const filters = document.getElementById("filters");
      const idFilters = document.getElementById("idFilters");
      const classFilters = document.getElementById("classFilters");
      const idFiltersGroup = document.getElementById("idFiltersGroup");
      const classFiltersGroup = document.getElementById("classFiltersGroup");
      const selectAllBtn = document.getElementById("selectAllBtn");
      const deselectAllBtn = document.getElementById("deselectAllBtn");

      let cleanedXML = "";
      let workingDocument = null;
      let selectedIds = new Set();
      let selectedClasses = new Set();

      // Allowed tags
      const ALLOWED_TAGS = [
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "p",
        "span",
        "code",
        "pre",
        "ul",
        "ol",
        "li",
        "strong",
        "em",
        "b",
        "i",
      ];

      // Upload area click
      uploadArea.addEventListener("click", () => {
        fileInput.click();
      });

      // File input change
      fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) {
          processFile(file);
        }
      });

      // Drag and drop
      uploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadArea.classList.add("dragover");
      });

      uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("dragover");
      });

      uploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadArea.classList.remove("dragover");
        const file = e.dataTransfer.files[0];
        if (file) {
          processFile(file);
        }
      });

      // Process uploaded file
      function processFile(file) {
        if (!file.name.endsWith(".html") && !file.name.endsWith(".htm")) {
          showStatus("Please upload an HTML file (.html or .htm)", "error");
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const htmlContent = e.target.result;
            const { doc, ids, classes } = parseHTML(htmlContent);
            workingDocument = doc;

            // Initialize filters
            setupFilters(ids, classes);

            // Generate initial XML
            regenerateXML();

            showStatus("File processed successfully!", "success");
          } catch (error) {
            showStatus(`Error processing file: ${error.message}`, "error");
          }
        };
        reader.readAsText(file);
      }

      // Setup attribute filters
      function setupFilters(ids, classes) {
        idFilters.innerHTML = "";
        classFilters.innerHTML = "";
        selectedIds.clear();
        selectedClasses.clear();

        // Setup ID checkboxes
        if (ids.size > 0) {
          ids.forEach((id) => {
            selectedIds.add(id);
            const item = createCheckbox(id, "id", true);
            idFilters.appendChild(item);
          });
          idFiltersGroup.style.display = "block";
        } else {
          idFiltersGroup.style.display = "none";
        }

        // Setup class checkboxes
        if (classes.size > 0) {
          classes.forEach((className) => {
            selectedClasses.add(className);
            const item = createCheckbox(className, "class", true);
            classFilters.appendChild(item);
          });
          classFiltersGroup.style.display = "block";
        } else {
          classFiltersGroup.style.display = "none";
        }

        // Show filters section if there are any
        if (ids.size > 0 || classes.size > 0) {
          filters.classList.add("show");
        } else {
          filters.classList.remove("show");
        }
      }

      // Create checkbox element
      function createCheckbox(value, type, checked) {
        const item = document.createElement("div");
        item.className = "checkbox-item";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.id = `${type}-${value}`;
        checkbox.checked = checked;
        checkbox.addEventListener("change", (e) => {
          if (type === "id") {
            if (e.target.checked) {
              selectedIds.add(value);
            } else {
              selectedIds.delete(value);
            }
          } else {
            if (e.target.checked) {
              selectedClasses.add(value);
            } else {
              selectedClasses.delete(value);
            }
          }
          regenerateXML();
        });

        const label = document.createElement("label");
        label.htmlFor = `${type}-${value}`;
        label.textContent = value;

        item.appendChild(checkbox);
        item.appendChild(label);

        return item;
      }

      // Select/Deselect all buttons
      selectAllBtn.addEventListener("click", () => {
        document
          .querySelectorAll('.checkbox-item input[type="checkbox"]')
          .forEach((cb) => {
            cb.checked = true;
          });
        // Rebuild selected sets
        selectedIds.clear();
        selectedClasses.clear();
        idFilters.querySelectorAll("input").forEach((cb) => {
          selectedIds.add(cb.id.replace("id-", ""));
        });
        classFilters.querySelectorAll("input").forEach((cb) => {
          selectedClasses.add(cb.id.replace("class-", ""));
        });
        regenerateXML();
      });

      deselectAllBtn.addEventListener("click", () => {
        document
          .querySelectorAll('.checkbox-item input[type="checkbox"]')
          .forEach((cb) => {
            cb.checked = false;
          });
        selectedIds.clear();
        selectedClasses.clear();
        regenerateXML();
      });

      // Regenerate XML based on current selections
      function regenerateXML() {
        if (!workingDocument) return;

        const formatted = formatElement(workingDocument);
        cleanedXML = `<?xml version="1.0" encoding="UTF-8"?>\n<Root>\n${formatted}</Root>`;
        showPreview(cleanedXML);
      }

      // Parse HTML and extract attributes
      function parseHTML(htmlContent) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlContent, "text/html");

        let contentRoot;
        const bodyElement = doc.querySelector("body");
        const headElement = doc.querySelector("head");

        if (headElement || bodyElement) {
          if (bodyElement) {
            contentRoot = bodyElement;
            showStatus(
              "Found <body> tag - extracting content from body only",
              "info",
            );
          } else {
            throw new Error("HTML contains <head> but no <body> tag");
          }
        } else {
          contentRoot = doc.documentElement;
        }

        const workingContent = contentRoot.cloneNode(true);
        removeScriptsAndStyles(workingContent);
        removeUnwantedTags(workingContent);
        removeRedundantSpans(workingContent);

        // Extract unique IDs and classes
        const ids = new Set();
        const classes = new Set();

        workingContent.querySelectorAll("*").forEach((el) => {
          if (el.id) ids.add(el.id);
          if (el.className) {
            el.className.split(/\s+/).forEach((c) => {
              if (c) classes.add(c);
            });
          }
        });

        return { doc: workingContent, ids, classes };
      }

      // Remove script and style tags (critical for InDesign)
      function removeScriptsAndStyles(element) {
        // Remove all script tags
        element.querySelectorAll("script").forEach((el) => el.remove());
        // Remove all style tags
        element.querySelectorAll("style").forEach((el) => el.remove());
      }

      // Remove redundant wrapping spans (where entire content is wrapped in span)
      function removeRedundantSpans(element) {
        const allElements = element.querySelectorAll("*");

        allElements.forEach((el) => {
          // Check if element has exactly one child and that child is a span
          if (
            el.children.length === 1 &&
            el.children[0].tagName.toLowerCase() === "span"
          ) {
            const span = el.children[0];
            // Move all of span's children to parent
            while (span.firstChild) {
              el.insertBefore(span.firstChild, span);
            }
            // Remove the now-empty span
            span.remove();
          }
        });
      }

      // Remove unwanted tags
      function removeUnwantedTags(element) {
        const allElements = element.querySelectorAll("*");

        allElements.forEach((el) => {
          const tagName = el.tagName.toLowerCase();

          // Remove tags that are not allowed
          if (!ALLOWED_TAGS.includes(tagName)) {
            // Remove the element but keep its children
            while (el.firstChild) {
              el.parentNode.insertBefore(el.firstChild, el);
            }
            el.remove();
          }
        });

        // Also remove img, iframe, etc. that might have been missed
        const unwantedSelectors = [
          "img",
          "iframe",
          "video",
          "audio",
          "script",
          "style",
          "link",
          "meta",
        ];
        unwantedSelectors.forEach((selector) => {
          element.querySelectorAll(selector).forEach((el) => el.remove());
        });
      }

      // Escape special XML characters
      function escapeXML(text) {
        return text
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&apos;");
      }

      // Format individual element (each tag on one line)
      function formatElement(element) {
        let result = "";

        for (let node of element.childNodes) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const tagName = getTagName(node);
            const innerHTML = getInnerContent(node);

            // Only output if there's content (no empty tags)
            if (innerHTML) {
              result += `<${tagName}>${innerHTML}</${tagName}>\n`;
            }
          }
        }

        return result;
      }

      // Get tag name with id/class incorporated
      function getTagName(element) {
        let tagName = element.tagName.toLowerCase();
        let suffixes = [];

        // Add ID to tag name (PascalCase to differentiate from classes)
        if (element.id && selectedIds.has(element.id)) {
          suffixes.push(toPascalCase(element.id));
        }

        // Add all selected classes to tag name (camelCase)
        if (element.className) {
          const classNames = element.className
            .split(/\s+/)
            .filter((c) => c && selectedClasses.has(c))
            .map(c => toCamelCase(c));
          suffixes.push(...classNames);
        }

        // Combine tag name with all suffixes
        if (suffixes.length > 0) {
          return tagName + "_" + suffixes.join("_");
        }

        return tagName;
      }

      // Convert hyphenated strings to camelCase
      function toCamelCase(str) {
        return str.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase());
      }

      // Convert to PascalCase (capitalize first letter)
      function toPascalCase(str) {
        const camel = toCamelCase(str);
        return camel.charAt(0).toUpperCase() + camel.slice(1);
      }

      // Get inner content recursively (all on one line)
      function getInnerContent(element) {
        let content = "";

        for (let node of element.childNodes) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const tagName = getTagName(node);
            const innerHTML = getInnerContent(node);

            // Only include if there's content
            if (innerHTML) {
              content += `<${tagName}>${innerHTML}</${tagName}>`;
            }
          } else if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent.trim();
            if (text) {
              content += escapeXML(text);
            }
          }
        }

        return content;
      }

      // Show status message
      function showStatus(message, type) {
        status.textContent = message;
        status.className = `status ${type}`;
      }

      // Show preview
      function showPreview(content) {
        previewContent.textContent = content;
        preview.classList.add("show");
      }

      // Download XML
      downloadBtn.addEventListener("click", () => {
        const blob = new Blob([cleanedXML], { type: "application/xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "cleaned-output.xml";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showStatus("XML file downloaded!", "success");
      });
    </script>
  </body>
</html>
